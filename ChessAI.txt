#include "ChessAI.h"          // Include the header for ChessAI itself
#include "MoveGenerator.h"    // Needed to generate legal moves
#include "Constants.h"        // To access AI_SEARCH_DEPTH, DEFAULT_AI_TYPE, etc.
#include "ChessBitboardUtils.h" // For bitboard manipulation functions and move_to_string

#include <random>             // For std::random_device, std::mt19937_64, std::uniform_int_distribution
#include <iostream>           // For std::cerr to output error or debug messages
#include <vector>             // Required for std::vector to manage collections of moves
#include <algorithm>          // Required for std::min, std::max (for evaluation/search)
#include <chrono>             // REQUIRED: For std::chrono to measure search time

// Constructor for ChessAI.
// Initializes the random number generator used by the AI.
// The `rng_engine` is a member of the ChessAI class, so it's initialized here
// using `std::random_device` to ensure a non-deterministic seed for true randomness.
ChessAI::ChessAI() : rng_engine(std::random_device{}()) {
    // Initialize search statistics counters to zero.
    // They will be reset per search by `findBestMove`.
    nodes_evaluated_count = 0;
    branches_explored_count = 0;
    current_search_depth_set = 0;

    // In a real, more advanced chess engine, this constructor would also be responsible for:
    // - Initializing transposition tables (for caching search results and detecting repetitions).
    // - Loading opening books (to play predefined moves in the opening phase).
    // - Setting up any other persistent data structures required by the chosen search algorithm.
    // - Potentially configuring AI parameters (e.g., specific evaluation weights).
}

/**
 * @brief Evaluates the given chess board position and returns a numerical score.
 *
 * This evaluation function now consistently returns a score from **White's perspective**.
 * A positive score indicates an advantage for White, and a negative score indicates
 * an advantage for Black.
 *
 * It currently only considers material. Future enhancements will include
 * positional factors (e.g., pawn structure, king safety, piece activity, mobility),
 * which add more chess-specific intelligence.
 *
 * @param board The chess board position to evaluate (const reference, as its state is not modified).
 * @return An integer representing the evaluation score, always from White's perspective.
 * Scores are typically given in centipawns (1/100th of a pawn), so a pawn is 100.
 *
 * Example Material Values (in centipawns):
 * Pawn:   100
 * Knight: 320
 * Bishop: 330
 * Rook:   500
 * Queen:  900
 */
int ChessAI::evaluate(const ChessBoard& board) const {
    int score = 0; // Initialize score to zero.

    // Define standard piece values in centipawns.
    const int PAWN_VALUE   = 100;
    const int KNIGHT_VALUE = 320;
    const int BISHOP_VALUE = 330;
    const int ROOK_VALUE   = 500;
    const int QUEEN_VALUE  = 900;

    // Iterate through all 64 squares of the board to sum up material.
    for (int i = 0; i < 64; ++i) {
        // Add value for white pieces.
        if (ChessBitboardUtils::test_bit(board.white_pawns, i))    score += PAWN_VALUE;
        else if (ChessBitboardUtils::test_bit(board.white_knights, i)) score += KNIGHT_VALUE;
        else if (ChessBitboardUtils::test_bit(board.white_bishops, i)) score += BISHOP_VALUE;
        else if (ChessBitboardUtils::test_bit(board.white_rooks, i))  score += ROOK_VALUE;
        else if (ChessBitboardUtils::test_bit(board.white_queens, i)) score += QUEEN_VALUE;

        // Subtract value for black pieces.
        else if (ChessBitboardUtils::test_bit(board.black_pawns, i))   score -= PAWN_VALUE;
        else if (ChessBitboardUtils::test_bit(board.black_knights, i)) score -= KNIGHT_VALUE;
        else if (ChessBitboardUtils::test_bit(board.black_bishops, i)) score -= BISHOP_VALUE;
        else if (ChessBitboardUtils::test_bit(board.black_rooks, i))  score -= ROOK_VALUE;
        else if (ChessBitboardUtils::test_bit(board.black_queens, i)) score -= QUEEN_VALUE;
    }

    // The score is now always from White's perspective.
    // Example: If White is up a pawn, score is +100. If Black is up a pawn, score is -100.
    return score;
}

/**
 * @brief Implements the recursive Minimax search algorithm (in Negamax form).
 *
 * This function is implemented in a **Negamax** style. This means that at *every*
 * node, the function attempts to **maximize** the score for the `board.active_player`
 * at that specific node. The negation of the recursive call handles the alternating
 * turns correctly.
 *
 * @param board The current state of the chessboard (non-const reference).
 * @param depth The remaining depth to search. When depth reaches 0, the `evaluate`
 * function is called to get a static score.
 * @return The best score found for the `board.active_player` at the current node.
 * This score is from the perspective of the player whose turn it is at this `board` state.
 *
 */
int ChessAI::minimax(ChessBoard& board, int depth) {
    // Count this node as evaluated.
    nodes_evaluated_count++;

    // --- Base Case: Terminal Node or Max Depth Reached ---
    // When the search depth is 0, we've reached the end of our search horizon.
    // In this case, we statically evaluate the current board position.
    if (depth == 0) {
        int static_eval = evaluate(board); // Get score from White's perspective.
        // Return score from the perspective of the *current active player* at this leaf node.
        // If it's White's turn, return White's score. If it's Black's turn, return Black's score (-White's score).
        if (board.active_player == PlayerColor::White) {
            return static_eval; // White wants to maximize its own (White's) score.
        } else {
            return -static_eval; // Black wants to maximize its own (Black's) score, which is -White's score.
        }
    }

    MoveGenerator move_gen;
    std::vector<Move> legal_moves = move_gen.generate_legal_moves(board);

    // Add the number of legal moves generated at this node to the total branches explored.
    branches_explored_count += legal_moves.size();

    // If there are no legal moves from the current position, it's a terminal node.
    // This could be checkmate, stalemate, or insufficient material (though not fully detected yet).
    // In such cases, we evaluate the current board state directly.
    if (legal_moves.empty()) {
        // Special case for checkmate/stalemate should eventually be handled here.
        // Assign very large positive/negative values for checkmate.
        // For now, we use material evaluation as if it's a static position.
        int static_eval = evaluate(board); // Score from White's perspective.
        if (board.active_player == PlayerColor::White) {
            return static_eval;
        } else {
            return -static_eval;
        }
    }

    // Initialize `best_eval` to negative infinity for the current player.
    // Every call to `minimax` (in Negamax) tries to maximize its own score.
    int best_eval = -99999999; 

    // Iterate through all legal moves from the current position.
    for (const auto& move : legal_moves) {
        StateInfo info_for_undo; // Store board state before applying the move.

        // Apply the current move to the board.
        // This advances the game state. Crucially, `board.active_player` flips to the opponent.
        board.apply_move(move, info_for_undo);

        // Recursively call `minimax` for the next level (depth - 1).
        // The recursive call `minimax(board, depth - 1)` will now operate from the *opponent's* perspective
        // (since the opponent is now the `board.active_player`).
        // It will return the best score for the opponent from their perspective.
        // To get this score back to *our* perspective for comparison, we negate it.
        // This is the core of the Negamax principle: `score = -minimax(opponent_state, depth-1)`.
        int eval = -minimax(board, depth - 1); 

        // Update `best_eval` if the current move leads to a better score for the current player.
        best_eval = std::max(best_eval, eval);

        // Undo the move to restore the board to its original state.
        // This is vital for correctly exploring all other branches from this node.
        board.undo_move(move, info_for_undo);
    }
    return best_eval; // Return the maximum score found for the current player at this node.
}

/**
 * @brief Finds and returns the best legal move for the current active player on the given board.
 * This is the primary interface for the GameManager to request a move from the AI.
 *
 * This function's behavior is determined by the `DEFAULT_AI_TYPE` constant from `Constants.h`.
 *
 * @param board A non-constant reference to the current ChessBoard state.
 * This is crucial because the search algorithm will temporarily `apply_move()` and `undo_move()`
 * on this board object to explore different game lines.
 * @return The calculated best legal move. If no legal moves are found (e.g.,
 * due to checkmate or stalemate), it returns a default-constructed,
 * invalid `Move` (where `piece_moved_type_idx` is `PieceTypeIndex::NONE`).
 */
Move ChessAI::findBestMove(ChessBoard& board) {
    MoveGenerator move_gen; // Create an instance of the MoveGenerator to generate legal moves.

    // Generate all legal moves for the current board state.
    // This is the essential first step for any chess AI, as it can only consider valid moves.
    std::vector<Move> legal_moves = move_gen.generate_legal_moves(board);

    // Handle the case where there are no legal moves available.
    // This signifies a game termination condition (checkmate or stalemate).
    if (legal_moves.empty()) {
        std::cerr << "DEBUG: ChessAI: No legal moves found. Game is likely over (checkmate or stalemate)." << std::endl;
        return Move({0,0}, {0,0}, PieceTypeIndex::NONE); // Return a default/invalid move to signal no move.
    }

    // Use a `switch` statement based on the `DEFAULT_AI_TYPE` from `Constants.h`.
    // This allows for easy selection and testing of different AI behaviors.
    switch (DEFAULT_AI_TYPE) {
        case AIType::RANDOM_MOVER: {
            // --- Single-threaded Random Mover Implementation ---
            // This is the simplest AI behavior: it just picks a random legal move.
            
            // Create a uniform distribution to select a random index within the bounds of `legal_moves`.
            std::uniform_int_distribution<size_t> dist(0, legal_moves.size() - 1);
            
            // Select a random move using the ChessAI's main random number engine (`rng_engine`).
            Move chosen_move = legal_moves[dist(rng_engine)]; 
            
            // Output to standard error (cerr) for debugging purposes.
            std::cerr << "DEBUG: ChessAI (Random): Chose move: " << ChessBitboardUtils::move_to_string(chosen_move) << std::endl;
            
            return chosen_move; // Return the randomly chosen move.
        }
        case AIType::SIMPLE_EVALUATION: {
            // --- Simple Evaluation (1-Ply Search) Implementation ---
            // This AI will look one move ahead, evaluate each resulting position using
            // the `evaluate` function, and choose the move that leads to the best score.
            // This is a greedy approach and forms the foundation for more advanced searches.

            // Store the active player *before* considering any moves.
            // This is crucial because `evaluate` now returns a score from White's perspective,
            // and we need to know if we are maximizing (White) or minimizing (Black) that score.
            PlayerColor original_active_player = board.active_player;

            // Initialize `best_score` and a vector to hold moves that achieve this best score.
            int best_score;
            std::vector<Move> best_moves_candidates; // To store moves that are tied for the best score.

            // Set initial `best_score` based on whether we are maximizing or minimizing.
            // If it's White's turn, we want the highest score from White's perspective.
            // If it's Black's turn, we want the lowest score from White's perspective.
            if (original_active_player == PlayerColor::White) {
                best_score = -999999; // Initialize to negative infinity for maximizing.
            } else { // original_active_player == PlayerColor::Black
                best_score = 999999;  // Initialize to positive infinity for minimizing.
            }
            
            // Iterate through each legal move.
            for (const auto& move : legal_moves) {
                StateInfo info_for_undo; // Object to store the board state *before* applying the move.

                // Temporarily apply the current move to the board.
                // After this call, `board.active_player` will be the opponent's color.
                board.apply_move(move, info_for_undo);

                // Evaluate the new board position.
                // `evaluate(board)` now *always* returns a score from White's perspective.
                int current_score_from_white_perspective = evaluate(board); 

                // Determine whether to maximize (for White) or minimize (for Black)
                // the `current_score_from_white_perspective`.
                if (original_active_player == PlayerColor::White) {
                    // White wants to maximize its score (i.e., maximize the score from White's perspective).
                    if (current_score_from_white_perspective > best_score) {
                        best_score = current_score_from_white_perspective;
                        best_moves_candidates.clear(); // Clear old candidates as we found a new best score.
                        best_moves_candidates.push_back(move);
                    } else if (current_score_from_white_perspective == best_score) {
                        // If it's a tie for the best score, add this move to the candidates.
                        best_moves_candidates.push_back(move);
                    }
                } else { // original_active_player == PlayerColor::Black
                    // Black wants to minimize White's score (which means maximizing its own score).
                    if (current_score_from_white_perspective < best_score) {
                        best_score = current_score_from_white_perspective;
                        best_moves_candidates.clear(); // Clear old candidates as we found a new best score.
                        best_moves_candidates.push_back(move);
                    } else if (current_score_from_white_perspective == best_score) {
                        // If it's a tie for the best score, add this move to the candidates.
                        best_moves_candidates.push_back(move);
                    }
                }

                // Crucial: Undo the move to restore the board to its original state for the next iteration.
                board.undo_move(move, info_for_undo);
            }

            // Initialize final_chosen_move with a valid default (invalid) move.
            Move final_chosen_move = Move({0,0}, {0,0}, PieceTypeIndex::NONE);
            
            if (!best_moves_candidates.empty()) {
                // If multiple moves are tied for the best score, randomly pick one among them.
                // This breaks deterministic play when material scores are equal.
                std::uniform_int_distribution<size_t> dist(0, best_moves_candidates.size() - 1);
                final_chosen_move = best_moves_candidates[dist(rng_engine)];
            } else {
                // This case should theoretically not be reached if `legal_moves` was not empty.
                // It means no valid best move candidate was found. The default-initialized
                // `final_chosen_move` will be returned.
                std::cerr << "DEBUG: ChessAI (Simple Evaluation): No best candidates found, returning default invalid move (fallback)." << std::endl;
            }

            // Output for debugging.
            std::cerr << "DEBUG: ChessAI (Simple Evaluation): Chose move: " << ChessBitboardUtils::move_to_string(final_chosen_move) 
                      << " with score (White's perspective): " << best_score << std::endl;
            return final_chosen_move; // Return the chosen move.
        }
        case AIType::MINIMAX: {
            // --- Minimax Search Implementation ---
            // This AI will now perform a recursive Minimax search to a specified depth (`AI_SEARCH_DEPTH`).
            // It aims to find the best move for the `original_active_player` by assuming both
            // players play optimally.

            // Reset search statistics for this new top-level search.
            nodes_evaluated_count = 0;
            branches_explored_count = 0;
            current_search_depth_set = AI_SEARCH_DEPTH; // Store the initial depth for reporting.

            // Store the active player *before* initiating the search.
            // This player is the "root" player for whom we are finding the best move.
            PlayerColor original_active_player = board.active_player;

            int best_score; // This will store the best score found at the root for `original_active_player`.
            std::vector<Move> best_moves_candidates; // To store moves that tie for the optimal score.

            // Initialize `best_score` to negative infinity for the root player (maximizing their own score).
            best_score = -99999999; 
            
            // Record the start time of the search for performance metrics.
            auto start_time = std::chrono::high_resolution_clock::now();

            // Iterate through each of the legal moves from the current position (the root node).
            for (const auto& move : legal_moves) {
                StateInfo info_for_undo; // Store board state before applying the move.

                // Apply the move to the board. `board.active_player` flips to the opponent.
                board.apply_move(move, info_for_undo);

                // Recursively call the `minimax` function for the next level of the search.
                // `AI_SEARCH_DEPTH - 1` because one ply has already been consumed by applying `move`.
                // The `minimax` function will return a score from the perspective of the `board.active_player`
                // (which is now the opponent).
                // Therefore, we negate the result to get the score from *our* `original_active_player`'s perspective.
                int current_eval = -minimax(board, AI_SEARCH_DEPTH - 1); 

                // Compare `current_eval` (which is now from `original_active_player`'s perspective)
                // with `best_score` to find the optimal move at the root.
                // At the root, we always maximize the score for the `original_active_player`.
                if (current_eval > best_score) {
                    best_score = current_eval;
                    best_moves_candidates.clear(); // Clear old candidates, new best found.
                    best_moves_candidates.push_back(move);
                } else if (current_eval == best_score) {
                    // If scores are tied, add to candidates for random tie-breaking.
                    best_moves_candidates.push_back(move);
                }

                // Undo the move to restore the board for the next iteration of the root moves.
                board.undo_move(move, info_for_undo);
            }
            // Record the end time of the search.
            auto end_time = std::chrono::high_resolution_clock::now();
            // Calculate the duration of the search in microseconds.
            auto duration_microseconds = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);
            long long duration_ms = duration_microseconds.count() / 1000; // Convert to milliseconds
            
            // Calculate Nodes Per Second (NPS).
            long long nodes_per_second = 0;
            if (duration_ms > 0) { // Avoid division by zero
                nodes_per_second = (nodes_evaluated_count * 1000) / duration_ms;
            } else if (nodes_evaluated_count > 0) {
                // If duration is 0ms but nodes were evaluated, imply very high NPS.
                nodes_per_second = nodes_evaluated_count * 1000000; // Represents nodes/sec for <1ms searches
            }


            Move final_chosen_move = Move({0,0}, {0,0}, PieceTypeIndex::NONE); // Initialize with invalid move.
            if (!best_moves_candidates.empty()) {
                // If multiple moves are tied for the best score at the root, randomly pick one.
                // This adds variety to the engine's play when multiple moves are equally good.
                std::uniform_int_distribution<size_t> dist(0, best_moves_candidates.size() - 1);
                final_chosen_move = best_moves_candidates[dist(rng_engine)];
            } else {
                // Fallback: This case should not be reached if legal_moves was not empty.
                std::cerr << "DEBUG: ChessAI (Minimax): No best candidates found, returning default invalid move (fallback)." << std::endl;
            }

            // Output search statistics to stderr after the search is complete.
            std::cerr << "DEBUG: ChessAI (Minimax): Completed search to depth " << current_search_depth_set
                      << ". Nodes: " << nodes_evaluated_count
                      << ", Branches: " << branches_explored_count 
                      << ", Time: " << duration_ms << "ms"
                      << ", NPS: " << nodes_per_second << std::endl;

            std::cerr << "DEBUG: ChessAI (Minimax): Chose move: " << ChessBitboardUtils::move_to_string(final_chosen_move) 
                      << " with score (current player's perspective at root): " << best_score << std::endl;
            return final_chosen_move;
        }
        default:
            // Handle any unconfigured or unknown AI types as a fallback.
            std::cerr << "DEBUG: ChessAI: Unknown AIType configured. Falling back to random." << std::endl;
            // Fallback to random if an unknown AIType is specified.
            {
                std::uniform_int_distribution<size_t> dist(0, legal_moves.size() - 1);
                Move chosen_move = legal_moves[dist(rng_engine)];
                std::cerr << "DEBUG: ChessAI (Fallback from Unknown AIType): Chose move: " 
                          << ChessBitboardUtils::move_to_string(chosen_move) << std::endl;
                return chosen_move;
            }
    }
}
